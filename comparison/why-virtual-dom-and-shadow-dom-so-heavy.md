# 仮想DOMとShadow DOMはなぜ重いのか？

## 仮想DOM（Virtual DOM）

### 重くなる理由

#### 1. **メモリオーバーヘッド**
```javascript
// 実DOM + 仮想DOMの二重管理
実DOM: <div id="app">...</div>
仮想DOM: { type: 'div', props: { id: 'app' }, children: [...] }
```

#### 2. **差分計算（Diffing）のコスト**
- 状態が変更されるたびに新旧の仮想DOMツリーを比較
- O(n³)の問題を最適化してもO(n)の計算は必要
- 大規模なツリーでは顕著な遅延

#### 3. **Reconciliation（調整）プロセス**
```javascript
// 更新フロー
1. 状態変更
2. 新しい仮想DOM生成
3. 差分計算
4. 実DOMへのパッチ適用
```

### パフォーマンスへの影響
- **初回レンダリング**: 仮想DOM構築の追加コスト
- **更新時**: 差分計算 + DOM操作
- **メモリ使用**: 実DOM + 仮想DOMの二重保持

---

## Shadow DOM

### 重くなる理由

#### 1. **独立したレンダリングコンテキスト**
```javascript
// 各Shadow Rootが独立した環境を持つ
element.attachShadow({ mode: 'closed' })
├── 独立したCSSOM
├── 独立したイベントシステム
└── 独立したレイアウト計算
```

#### 2. **スタイル計算の重複**
```css
/* グローバルCSS: 1回の計算 */
.button { color: red; }

/* Shadow DOM: N個のコンポーネント = N回の計算 */
:host { ... }
::slotted(*) { ... }
```

#### 3. **Slotメカニズムのオーバーヘッド**
- コンテンツの配信と再配置
- Light DOMとShadow DOMの協調
- 動的なslot変更の追跡

#### 4. **イベント処理の複雑化**
```javascript
// イベントの再ターゲティング
Shadow境界を越える際のevent.target変更
composedPath()による経路追跡
```

### パフォーマンスへの影響
- **作成時**: Shadow Root生成 + スタイル解析
- **レンダリング**: 独立したレイアウト計算
- **メモリ使用**: コンポーネント数 × スタイルコンテキスト

---

## パフォーマンス比較表

| 項目 | 仮想DOM | Shadow DOM | 通常のDOM |
|------|---------|------------|-----------|
| **初期化コスト** | 中 | 高 | 低 |
| **更新コスト** | 高 | 低 | 低 |
| **メモリ使用量** | 高（二重管理） | 高（独立コンテキスト） | 低 |
| **スタイル計算** | 通常 | コンポーネント数に比例 | 通常 |
| **主な用途** | 状態管理が複雑なアプリ | 完全な隔離が必要な場合 | シンプルなアプリ |

---

## ベンチマーク例

### 1000要素の作成時間
```javascript
通常のDOM:    ~15ms
仮想DOM:      ~30ms（仮想DOM構築含む）
Shadow DOM:   ~80ms（Shadow Root + スタイル解析）
```

### メモリ使用量（1000要素）
```javascript
通常のDOM:    ~5MB
仮想DOM:      ~10MB（実DOM + 仮想DOM）
Shadow DOM:   ~15MB（独立したスタイルコンテキスト）
```

---

## まとめ

### 仮想DOMが重い場面
- 頻繁な状態更新
- 大規模なコンポーネントツリー
- 複雑な差分計算が必要な場合

### Shadow DOMが重い場面
- 多数のコンポーネントインスタンス
- 複雑なスタイル定義
- 頻繁なコンポーネント作成/破棄

### 最適な選択
- **仮想DOM**: 複雑な状態管理が必要だが、コンポーネント数は中規模
- **Shadow DOM**: 完全なカプセル化が必須で、パフォーマンスは二の次
- **Svelte（コンパイラ）**: パフォーマンスを最優先し、両方の問題を回避